# 4-5 콜백 지옥과 비동기 제어

### 동기 vs 비동기

동기: CPU 계산으로 인해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드

비동기: 별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드

### 콜백 지옥이란?

콜백 함수를 익명 함수로 반복해서 전달하다 보니 코드의 들여쓰기가 감당하기 힘들 정도로 깊어지는 현상. 

주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하는데 가독성도 떨어지고 코드를 수정하기도 어렵다는 단점이 있다.

**익명함수를 기명함수로 바꾸어 가독성을 높인 예**

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled.png)

→ 가독성은 높아졌으나 일회성 함수를 전부 변수에 할당하는 것은 비효율적인 작업이다.

**ES6 Promise를 사용하여 콜백 지옥을 해결한 예**

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%201.png)

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%202.png)

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%203.png)

→ new 연산자와 함께 호출한 Promise의 인자에 넘겨주는 콜백 함수는 호출할 때 바로 실행된다.

하지만 콜백 함수 내부의 resolve 혹은 reject 함수 둘 중 하나라도 실행되지 않으면 then(다음) 또는 catch(오류 구문)으로 넘어가지 않는다.

→ 따라서 비동기 작업이 완료될 때 resolve 혹은 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능하다

**ES6 Generator를 사용하여 콜백 지옥을 해결한 예**

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%204.png)

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%205.png)

‘*’이 붙은 함수가 Generator 함수이다. Generator 함수를 실행하면 Iterator가 반환되는데 이는 next라는 메소드를 가진다. 

next 메소드를 호출하면 Generator 함수 내부의 맨 처음 yield에서 함수 실행을 멈춘다. 이후 next 메소드를 다시 호출하면 앞서 멈췄던 지점에서 시작하여 다음 yield에서 함수 실행을 멈춘다.

→ 즉 비동기 작업이 완료되는 시점마다 next 메소드를 호출하면 Generator 함수 내부의 소스가 위에서 아래로 순차적으로 실행된다.

**ES2017 async/await를 사용하여 콜백 지옥을 해결한 예**

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%206.png)

![Untitled](4-5%20%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%205dc416ecf71846399a40d8053c4f92a5/Untitled%207.png)

→ 비동기 작업을 수행하려는 함수 앞에 async를 표기하고 함수 내부의 비동기 작업이 필요한 위치마다 await를 표기한다. 이렇게 함으로써 뒤의 내용들이 Promise로 전환되고 해당 내용이 resolve된 이후 다음 작업이 진행된다.