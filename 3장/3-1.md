# 3-1 상황에 따라 달라지는 this

this는 실행컨텍스트가 생성될 때 결정됨. 즉 함수를 호출할 때 결정된다.

## 3-1-1 전역 공간에서의 this

전역 공간에서 this는 전역 객체를 가리킨다.

**‘전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티의 할당한다’**

```cpp
var a = 1;
console.log(a);    //1
console.log(window a);    //1
console.log(this a);    //1
```

- 전역공간에서 변수 a에 1을 할당하니 window.a(전역객체)와 this.a 모두 1로 출력된다.
- window(전역객체)의 프로퍼티로도 a가 할당되므로 window.a가 1이 된다.

→ window의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 같이 동작한다. 

→전역 변수 선언 시 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다. → 자바스크립트의 모든 변수는 실행 컨텍스트 LexicalEnvironment의 프로퍼티로서 동작

## 3-1-2 메서드로서 호출할 때 그 메서드 내부에서의 this

함수를 실행하는 방법

1. 함수로서 호출하는 경우
2. 메서드로서 호출하는 경우

차이점: 독립성 (함수는 독립적으로 지능을 수행하지만, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.)

- 어떤 함수를 객체의 프로퍼티에 할당한다고 메서드가 되는 것이 아니라, 객체의 메서드로서 호출할 경우에만 메서드로 동작
- ‘함수로서의 호출’, ‘메서드로서의 호출’ 구분하는 방법: 함수 앞에 점(.)의 유무 차이

## 3-1-3 함수로서 호출할 때 그 함수 내부에서의 this

**함수 내부에서의 this**

this: 지정되지 않으므로 전역 객체(설계상의 오류)

**메소드 내부 함수에서의 this**

메소드 내부 함수 역시 함수를 호출할 때 함수 혹은 메서드로 호출했는지만 파악하면 this의 값을 알 수 값을 정확히 알 수 있다. 

this 바인딩에 관해서는 함수 실행 주변 환경 관계 없이 호출 구문 앞에 점이나 대괄호 표기만 보면 된다.

**this를 바인딩하지 않는 함수**

es6에서는 함수 내부에서 this가 전역객치를 바라보는 문제를 보완하고자 this를 바인딩하지 않는 **화살표 함수** 도입

## 3-1-4 콜백 함수 호출 시 그 내부에서의 this

**콜백함수?**

 함수 A의 제어권을 다른 함수(또는 메소드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다.

콜백 함수도 기본적으로 함수이기에 this가 전역 객체를 참조하지만 콜백 함수는 제어권을 가진 함수의 내부 로직에 따라 실행되므로 제어권을 가진 함수에서 별도로 this가 될 대상을 지정할 경우 그 대상을 참조한다.

## 3-1-5 생성자 함수 내부에서의 this

**생성자 함수?**

어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수

(객체지향 언어에서 생성자를 클래스, 클래스로 만든 객체를 인스턴스라고 한다.)

new 명령어와 함께 함수를 호출하면 해당 함수는 생성자로서도 동작하게 된다. 어떤 함수가 생성자 함수로서 호출된 경우 내부 this는 새로 만들 구체적인 인스턴스 자신이 된다.